# Random Number Generator

> "Anyone attempting to produce random numbers
by purely arithmetic means is, of course, in a state of sin." 
>
> -- <cite> John Von Neumann </cite> 


Random numbers are fundamentally important to security solutions. There are two types of random number generators including **pseudo-random number generators** (PRNGs) and **cryptographically secure pseudo-random number generators** (CPRNGs).  













# Pseudo-Random Number Generators



A PRNG typically takes a single number as the input (i.e., the seed) and then output a stream of numbers. The outputed numbers should be statistically random. However, such a stream of random numbers should be reproducible. Specifically, given the same seed, a PRNG should generate the same sequence of random numbers.  

PRNGs were invented for simulations and scientific computations rather than security, where a salient example is the Monte Carlo method. 

The following example shows how to use a PRNG in python.  

```python
>>> import random
>>> random.seed(0)
>>> for i in range(1, 10): random.randint(1, 100)
... 
50
98
54
6
34
66
63
52
39
>>> random.seed(0)
>>> for i in range(1, 10): random.randint(1, 100)
... 
50
98
54
6
34
66
63
52
39
```

When the seed value is not specified, the current system time will be used as the seed value. For example, the following example will lead to two different sequences of random numbers. 

```python
>>> random.seed()
>>> for i in range(1, 10): random.randint(1, 100)
...
7
15
16
48
60
72
1
10
74
>>> random.seed()
>>> for i in range(1, 10): random.randint(1, 100)
...
11
22
58
74
71
27
49
19
52
```

The reason is that when ```random.seed()``` is used twice, the system time differs. Therefore, these two sequences are generated based on different seed values. However, if you can predict the time at which the seed function was invoked, you can still reproduce the sequence of random numbers. 



Almost all language support PRNGs. The following table (incompletely) summarizes PRNGs in popular languages. 

|Language|APIs|
|:---|---:|
|C/C++|rand(), random(), seed()|
|Windows|UuidCreateSequential|
|C#/VB|Random class|
|Java|java.util.Random|
|JavaScript|Math.random()|
|Python|random|
|PHP|rand(), srand(), mt_rand(), and mt_srand()|


# Cryptographically Secure Pseudo-Random Number Generator


A CPRNG is a PRNG but not vice versa. Specifically, numbers generated by a CPRNG have to satisfy the requirements of statistical randomness. In addition, they need to be **unpredictable**. 


Therefore, whenever you need unpredictability of random data, CPRNGs must be your choice. Examples of applications include, but are not limited to

+ Cryptographic key generation
+ Passcode generation
+ Session ID generation
+ Sequence number and port randomization



Taking for example Fortuna, a CPRNG used by FreeBSD and Apple OSes, it has three major components:

+ Generator: it expands a 256-bit seed into a sequence of random bits. 
+ Accumulator: it collects random data from various sources (of an operating system). 
+ Reseeding: it resets the seed from accumulated random data. 

Interested readers can find the design of Fortuna in Chapter 9 of [Cryptography Engineering](https://www.schneier.com/books/cryptography-engineering/). Here I reuse the figure below ([figure source](https://blog.ligos.net/images/Building-A-CRNG-Terninger-1-Introduction/fortuna-diagram.png)) to illustrate the design of Fortuna. 

![Fortuna](https://blog.ligos.net/images/Building-A-CRNG-Terninger-1-Introduction/fortuna-diagram.png)


Since a CPRNG needs to collect random data from sources of an OS, its implementation will get OSes involved. Fortunately, modern OSes have built-in CPRNGs and make their output (i.e., a sequence of unpredictable numbers) easily accessible to applications and users. For example, Linux/Unix systems have their CPRNGs to offer a stream of random numbers through ```/dev/random``` or ```/dev/urandom```. These two files are very similar but they do have subtle but fundamental differences. Interested readers can find the discussion from [this wiki entry](https://en.wikipedia.org/wiki//dev/random). 

Specifically, you can directly read $n$ bytes of random data from this file. 


```bash
$hexdump -n 10 -C //dev/urandom
00000000  0b dd 70 05 dc fc 3c ec  51 38                    |..p...<.Q8|
0000000a
$hexdump -n 10 -C //dev/urandom
00000000  d3 f4 7f 39 9f b2 62 c3  56 9c                    |...9..b.V.|
0000000a
$hexdump -n 10 -C //dev/urandom
00000000  07 fc 49 e9 73 64 0d d6  22 0e                    |..I.sd..".|
0000000a
```

You can also access this file directly from your program like this.  

```python
>>> with open("/dev/urandom", "rb") as f:
...     print(repr(f.read(10)))
...
b'\n\x05\x05\xd3Q\xccP\xb4\xf8g'
```

## Read Data From ```/dev/random``` and/or ```/dev/urandom```

A programming langauge may have a wrapper that helps you access the file and convert a byte sequence into a value with more readable format. For example, Python offers the ```os.urandom()``` method or the ```random.SystemRandom``` class, which essentially gets random values offered by underlying operating systems. It is worth noting that you do not need to, and you should not, specificy the seed when you use a CPRRNG. The ```os.urandom()``` method or the ```random.SystemRandom``` class ignore ```seed()```, so you do not need to worry about the seeding issue.  

When you use ```os.urandom()```, you typically need to convert a byte sequence to the data with the type you want. 
```python
>>> import os
>>> os.urandom(10)
b'\x0e%\xb0\xbeCTJ\xe9\xbei'
```

```random.SystemRandom``` makes it easier to get values with specific types. 

```python
>>> import random
>>> system_random = random.SystemRandom()
>>> print(system_random.randint(1, 1000))
939
>>> print(system_random.randint(1, 1000))
406
```

## Using As Seed Data From ```/dev/random``` and/or ```/dev/urandom```

Java uses ```SecureRandom``` class to provide CPRNG functionalities. 
Different from the ```os.urandom()``` method or the ```random.SystemRandom``` in python, the ```SecureRandom``` class does not generate random numbers by reading and transforming data from ```/dev/random``` or ```/dev/urandom```. Instead, it has it own CPRNG algorithm. However, the ```SecureRandom``` class does need true randomness as the seed to bootstrap its generation process. 

Typically, you do not need to explicitly seed the ```SecureRandom``` class. In this case, it will use OSes' default sources of randomness (e.g., ```/dev/urandom```). The following code presents a correct implementation. 

```java
SecureRandom secRan = new SecureRandom(); 
byte[] ranBytes = new bytes[20];
secRan.nextBytes(ranBytes); 
```

Nevertheless, different from the ```os.urandom()``` method or the ```random.SystemRandom``` in python, the ```SecureRandom``` class does offer the method to explicitly seed a CPRNG. ***It should be explicitly seeded only when you have a better source of randomness compared to the underlying OS' default randomness source***, which is very rare. A possible case is that you have a hardware-based random number generator that outperforms your OS-based one. When the explicit seeding is used incorrectly, things could go very wrong, which will be discussed later. 


# What Might Go Wrong? 

## Using PRNGs When CPRNGs Are Needed

Things may go seriously wrong when you want to generate unpredictable random data but you use PRNGs rather than CPRNGs.

The following example includes a function named ```genPwdResetLin(base)``` to generate a link for password reset. It uses ```random.randint()``` to generate a random number, which will later be used for building the link. Unfortunately, ```random.randint()``` implicitly uses the current time as the seed. Therefore, an attacker can estimate the generation time of a link, she can enumerate all time values around the estimated generation time and regenerate the link. 

```python
import random
import datetime

def genPwdResetLink(base):
    n = random.randint(1, 10000000)
    return base + str(n)
    
print(genPwdResetLink("hxxp://mypage.com/pwdreset.php?id="))
```

In order to fix this vulnerability, one should use a CPRNG, where the patched code is described below. The patched code uses ```random.SystemRandom()```. 


```python
import random

def genPwdResetLink(base):
    system_random = random.SystemRandom()
    n = random.randint(1, 10000000)
    return base + str(n)
    
print(genPwdResetLink("hxxp://mypage.com/pwdreset.php?id="))
```

## Unnecessary Seeding

It may backfire when seeding is incorrectly used for CPRNGs. Java does make it possible to seed its CPRNG via ```SecureRandom```. It is worth noting that if one creates two instances of ```SecureRandom``` with the same seed, these two CPRNG instances will generate identical sequences of numbers (i.e., degrading into a PRNG).  Following Java examples are vulnerable. 

```java
//Bad Examples
String timeStamp = new SimpleDateFormat("yyyy.MM.dd.HH.mm.ss").format(new java.util.Date());
byte[] seed = timeStamp.getBytes();
SecureRandom random1 = new SecureRandom(seed); //seeding with low entropy source. 

SecureRandom random2 = new SecureRandom() ; 
random1.setSeed(System.currentTimeMillis() % 1000); //seeding with low entropy source

byte[] b = "123".getBytes() ;
SecureRandom random3 = new SecureRandom(b) ; // seeding with a constant. 
  
SecureRandom random4 = SecureRandom.getInstance("SHA1PRNG") ;
random4.setSeed(123); // seeding with a constant.
```

The following example is secure since the seed of the ```rndGen``` is coming from a ```SecureRandom``` instance that is implicitly seeded. In fact, the first ```SecureRandom``` class, ```seedGen```, returns 20 bytes of data from ```/dev/urandom``` through ```generateSeed()```. In other words, ```rndGen``` in this implementation is equally secure compared to the scenario in which it is not explicitly seeded. Nevertheless, you should not label this example as *vulnerable* (e.g., when you perform code review or static program analysis). 

```java
SecureRandom seedGen = new SecureRandom(); //only for generating seed
byte[] seed = seedGen.generateSeed(20); //generate 20-byte seed
SecureRandom rndGen = new SecureRandom(seed);  
```



# CWE

+ CWE-330: Use of Insufficiently Random Values
+ CWE-331: Insufficient Entropy
+ CWE-332: Insufficient Entropy in PRNG
+ CWE-333: Improper Handling of Insufficient Entropy in TRNG
+ CWE-339: Small Seed Space in PRNG



# References

+ [Cryptography Engineering
Design Principles and Practical Applications (Chap. 9)](https://www.schneier.com/books/cryptography-engineering/)
+ [Secure Programming with Static Analysis (Chap. 11)](https://www.amazon.com/Secure-Programming-Static-Analysis-Brian/dp/0321424778/ref=sr_1_1?crid=3R8TSZQF3EUM3&keywords=Secure+Programming+with+Static+Analysis&qid=1669435238&sprefix=%2Caps%2C128&sr=8-1)
+ [24 Deadly Sins of Software Security: Programming Flaws and How to Fix Them (Chap. 20)](https://www.amazon.com/Deadly-Sins-Software-Security-Programming/dp/0071626751/ref=sr_1_1?crid=1VHXWZ5LJGP6E&keywords=24+deadly+sins+of+software+security&qid=1669435264&sprefix=sin+security+soft%2Caps%2C90&sr=8-1)
+ [Cryptographically Secure Pseudo-Random Number Generator (CSPRNG)](https://www.veracode.com/blog/research/cryptographically-secure-pseudo-random-number-generator-csprng)
+ [Everything about Java's SecureRandom](https://metebalci.com/blog/everything-about-javas-securerandom/)
+ [The Java SecureRandom Class](https://www.baeldung.com/java-secure-random)

